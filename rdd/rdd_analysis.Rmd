---
title: "rdd"
output: html_document
---

```{r setup, include=FALSE}
library(tidyverse)
library(MASS)
library(lme4)
library(rsq)
df <- read.csv("../data/clean_fees_rdd.csv")

```


```{r}

df <- dplyr::select(df, -MapBlkLot_Master, -X, -geometry)

df <- df %>%
  mutate_if(function(x) { is.numeric(x) & n_distinct(x) == 2}, as.logical)
lmh <- c('_low', '_med', '_high')
df['Upzone_Ratio_Bin'] = cut_number(df$Upzone_Ratio, 
                                    3, 
                                    labels=lmh)
df['land_value_bin'] = cut_number(df$assessed_land_value, 3, 
                                  labels=lmh)
df['improvement_value_bin'] = cut_number(df$assessed_improvement_value, 
                                         3,
                                         labels=lmh)

df$x <- df$x / 100
df$y <- df$y / 100
df$x <- scale(df$x, scale=FALSE)
df$y <- scale(df$y, scale=FALSE)


df$assessor_neighborhood <- addNA(df$assessor_neighborhood)
df$exemption_code_definition <- addNA(df$exemption_code_definition)
df$status_code <- addNA(df$status_code)
df$lot_code <- addNA(df$lot_code)
df$zoning_code <- addNA(df$zoning_code)
df$construction_type <- addNA(df$construction_type)

df <- df[df$number_of_bedrooms >= 0 & !is.na(df$number_of_bedrooms),]
df <- df[df$basement_area >= 0 & !is.na(df$basement_area),]
df <- df[df$year_property_built <= 2023 & !is.na(df$year_property_built),]
df[is.na(df$year_property_built), 'year_property_built'] <- 0
df$Net_Units_Completed[is.na(df$Net_Units_Completed) | (df$Net_Units_Completed < 0)] <- 0

df['yearBuiltMissing'] <- (df$year_property_built == 0 | is.na(df$year_property_built))
# Area code that affects taxes
df$tax_rate_area_code <- as.factor(df$tax_rate_area_code)

# Property records are split up into volumes for organizational purposes.
# This is likely highly correlated with neighborhoods or census tracts.
df$volume_number <- as.factor(df$volume_number)
df$supervisor_district <- as.factor(df$supervisor_district)

df$Developed <- as.logical(df$Developed)
```

# Binomial

```{r}
table(nearby$zillow_neighborhood_name, nearby$tier)
```

```{r}

nearby <- df[abs(df$dist_to_boundary) < 10, ]

bern.mod <- glm(Developed ~ zp_DensRestMulti + zp_OfficeComm + zp_PDRInd + 
    zp_RH3_RM1 + zp_RH2 + zp_FormBasedMulti + log1p(Envelope_1000) + 
    use_definition + lot_code + percent_of_ownership + 
    log1p(misc_exemption_value) + log1p(permit_1) + log1p(permit_2) +
    log1p(permit_3) + log1p(permit_4) + log1p(permit_5) + log1p(permit_6) + 
    log1p(permit_7) + log1p(permit_8)  + Envelope_1000 + 
    log1p(number_of_units) + log1p(number_of_bedrooms) + 
    log1p(year_property_built) + 
    Upzone_Ratio_Bin + lot_depth + log1p(assessed_personal_property_value) + 
    log1p(lot_area) + Residential_Dummy + Historic + land_value_bin + 
    improvement_value_bin + Residential_Dummy:Historic + 
      higher_commercial_fee + 
      (dist_to_boundary + tier)^2 + (zillow_neighborhood_name * tier) + Residential_Dummy:improvement_value_bin,
    data=nearby, na.action='na.omit', family='binomial')

summary(bern.mod)
```


```{r}
bern.base.init <-  glm(Developed ~ tier * dist_to_boundary,
                       data=nearby, na.action='na.omit', family='binomial')
summary(bern.base.init)

```


```{r}
bern.step.mod <- stepAIC(bern.base.init, direction="forward", scope=list(upper=bern.mod$formula,
                                                                    lower=bern.base.init$formula), trace=FALSE)
rsq.kl(bern.step.mod)
summary(bern.step.mod)
bern.step.mod
```
# Poisson
```{r}
pois.base.init <- glm(Net_Units_Completed ~ dist_to_boundary * tier,
                       data=nearby, na.action='na.omit', family='poisson')
summary(pois.base.init)

```


```{r}
pois.mod <- glm(Net_Units_Completed ~ 
                  log1p(Envelope_1000) +
                  log1p(permit_8) + log1p(number_of_units) + 
                  log1p(year_property_built) + Upzone_Ratio_Bin + lot_depth +
                  log1p(assessed_personal_property_value) + log1p(lot_area) +
                  Residential_Dummy + Historic + land_value_bin + improvement_value_bin +
                  dist_to_boundary * tier + 
                  zillow_neighborhood_name * tier,
                data=nearby, na.action='na.omit', family='poisson', x=TRUE)


summary(pois.mod)
```



```{r}
pois.step.mod <- stepAIC(pois.base.init, direction="forward", scope=list(upper=pois.mod$formula,
                                                                    lower=pois.base.init$formula),
                         k=log(nrow(nearby)), trace=FALSE)

pois.summ <- summary(pois.step.mod, dispersion = 1.470667)

round(exp(c(pois.summ$coef['tiertier2', 'Estimate'] - 1.96 * pois.summ$coef['tiertier2', 'Std. Error'],
            pois.summ$coef['tiertier2', 'Estimate'] + 1.96 * pois.summ$coef['tiertier2', 'Std. Error'])), 6)


exp(c(pois.summ$coef['dist_to_boundary', 'Estimate'] - 1.96 * pois.summ$coef['dist_to_boundary', 'Std. Error'],
            pois.summ$coef['dist_to_boundary', 'Estimate'] + 1.96 * pois.summ$coef['dist_to_boundary', 'Std. Error']))

exp(c(pois.summ$coef['dist_to_boundary:tiertier2', 'Estimate'] - 1.96 * pois.summ$coef['dist_to_boundary:tiertier2', 'Std. Error'],
            pois.summ$coef['dist_to_boundary:tiertier2', 'Estimate'] + 1.96 * pois.summ$coef['dist_to_boundary:tiertier2', 'Std. Error']))

pois.summ$coefficients['tiertier2', 'Pr(>|z|)']
pois.summ$coefficients['dist_to_boundary', 'Pr(>|z|)']
pois.summ$coefficients['dist_to_boundary:tiertier2', 'Pr(>|z|)']

rsq.kl(pois.step.mod) 

summary(pois.step.mod, dispersion = 1.470667)
```


```{r}
# Phi hat is 4.47
scaled.dev.resids <- residuals(pois.step.mod, type='deviance') / (1 - influence(pois.step.mod)$hat)
var(scaled.dev.resids[is.finite(scaled.dev.resids)])
```

```{r}
calc_marginal_effects <- function(model, newdata, treatment_var = "tier") {
  # Duplicate the data
  newdata1 <- newdata2 <- newdata
  
  # Set treatment variable to 1 in the first dataset and to 0 in the second
  newdata1[[treatment_var]] <- "tier1"
  newdata2[[treatment_var]] <- "tier2"
  
  # Predict the counts for both scenarios
  pred1 <- predict(model, newdata=newdata1, type="response")
  pred2 <- predict(model, newdata=newdata2, type="response")
  
  # Sum the marginal effects across all units
  sum_marginal_effects <- sum(pred1 - pred2)
  
  return(sum_marginal_effects)
}

calc_marginal_effects(pois.step.mod, df)

```

```{r}
pairwise_correlations <- pois.step.mod$x %>%
  scale() %>%
  correlate() %>%
  stretch() 

pairwise_correlations[!is.na(pairwise_correlations['r']),] %>%
  filter(abs(r) > .5) %>%
  arrange(r) %>%
  filter(x > y)
```

```{r}
plot(scale(df$x)*(df['tier'] == 'tier2'), df$y, s=.01)
```