---
title: "iv_analysis"
output: html_document
---

```{r}
require(plm)
require(tidyverse)
library(sandwich)
library(knitr) 
library(rsq)
require(gridExtra)
```

```{r}
df <- read.csv('./panel_fires.csv')


df['Developed'] = df['Developed'] == 'True'
```

#EDA 

```{r eda}
to_plot <- df
plot.upzone <- ggplot(to_plot) +
  geom_boxplot(aes(x=Developed, y=log1p(Upzone_Ratio))) +
  ylab('Upzone Ratio (log)') +
  xlab('') +
  theme_bw() + 
  scale_x_discrete(labels = c("FALSE" = "Not Developed", "TRUE" = "Developed")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1,  size=12))+
  theme(text = element_text(size = 13)) + 
  scale_y_continuous(limits = c(0, 2))

plot.yr <- ggplot(to_plot[(to_plot$years_since_last_sale > 0) & !is.na(to_plot$years_since_last_sale),]) +
  geom_boxplot(aes(x=Developed, y=years_since_last_sale)) +
  ylab('Years Since Last Sale') +
  xlab('') + 
  theme_bw() +
     scale_x_discrete(labels = c("FALSE" = "Not Developed", "TRUE" = "Developed")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1,  size=12)) +
  theme(text = element_text(size = 13))


grid.arrange(plot.upzone, plot.yr, ncol=2)

g <- arrangeGrob(plot.upzone, plot.yr, ncol=2)
ggsave("./figures/eda_boxplots.png", g, height=3.5, width=7)
```


```{r eda2}


plot.no.year <- ggplot(df[!is.na(df$use_definition) & (df$use_definition != '') & (df$use_definition != 'NaN'),], 
                       aes(x=use_definition, fill=Developed)) +
  geom_bar(position = "fill") +
  ylab('Proportion Developed') +
  xlab('Existing Use') + 
  scale_y_continuous(labels = scales::percent, limits = c(0.0, .01)) +
    scale_fill_manual(values = c("TRUE" = "black", "FALSE" = "white")) +
  coord_flip() +
  theme_bw() +
   theme(axis.text.y = element_text(angle = 0, hjust = 1,  size=10),
         axis.title.x = element_text(size = 14),
         axis.text.x = element_text(size=12),  legend.position = "none") 

ggsave('./figures/eda_barplots.png', plot.no.year, height=2.5, width=7)
```

```{r correlation}
cor(df$Net_Units_Completed, df$revenue, use='pairwise.complete.obs')
cor(df$Developed, log10(1 + df$revenue), use='pairwise.complete.obs')

```

```{r eda_cor1}
# Initialize empty named vector to hold results
cor_results <- c()

# Loop through columns
for (i in 2:(ncol(df) - 12)) {
  col_name <- colnames(df)[i]
  col_data <- df[[i]]
  
  # Check if column is numeric or boolean
  if (is.numeric(col_data) || is.logical(col_data)) {
    # Calculate Pearson correlation coefficient
    cor_value <- cor(col_data, df$Developed, method = "pearson", use='pairwise.complete.obs')
    
    # Store result
    cor_results[col_name] <- cor_value
  }
}

# Sort the results based on the absolute value of correlation
sorted_cor_results <- cor_results[order(-abs(cor_results))]

# Return the ten columns with the largest absolute correlation values
top_10_cor_results <- head(sorted_cor_results, 12)

# Print results
print(top_10_cor_results[3:length(top_10_cor_results)])

```


```{r eda_cor2}
# Initialize empty named vector to hold results
cor_results <- c()

isDevelopedDf <- df[df$Developed,]
print(nrow(isDevelopedDf))
# Loop through columns
for (i in 2:(ncol(isDevelopedDf) - 12)) {
  col_name <- colnames(isDevelopedDf)[i]
  col_data <- isDevelopedDf[[i]]
  
  # Check if column is numeric or boolean
  if (is.numeric(col_data) || is.logical(col_data)) {
    # Calculate Pearson correlation coefficient
    cor_value <- cor(col_data, isDevelopedDf$Net_Units_Completed, method = "pearson", use='pairwise.complete.obs')
    
    # Store result
    cor_results[col_name] <- cor_value
  }
}

# Sort the results based on the absolute value of correlation
sorted_cor_results <- cor_results[order(-abs(cor_results))]

# Return the ten columns with the largest absolute correlation values
top_cor_results <- head(sorted_cor_results, 15)

# Print results
print(round(top_cor_results[2:length(top_cor_results)], 3))

```


```{r int}
aggregated_data <- df %>%
  group_by(Residential_Dummy, Historic) %>%
  summarise(
    mean_Developed = mean(log1p(Net_Units_Completed)),
    se = sqrt(var(log1p(Net_Units_Completed)) / n()),
    lower = mean_Developed - qt(0.95, n() - 1) * se,
    upper = mean_Developed + qt(0.95, n() - 1) * se
  )

# Create the plot
ggplot(aggregated_data, aes(x = as.factor(Residential_Dummy), y = mean_Developed, color = as.factor(Historic))) +
  geom_line(aes(group = as.factor(Historic))) +
  geom_point() +
  geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.1) +
  labs(
    title = "Interaction between Existing Residential Use\nand Historic Status",
    x = "Existing Residential Use",
    y = "Mean log(Units Built)",
    color = "Historic"
  ) +
  theme_minimal()

ggsave('two_way_res_history.png', width=6, height=2.5)
```

```{r clean}
df <- df %>%
  mutate(years_since_fire = ifelse(years_since_fire < 0, NaN, years_since_fire)) %>%
  mutate(fire_damage = ifelse(is.nan(years_since_fire), 0, fire_damage))


df[is.na(df$imputed_land_value), 'imputed_land_value'] <- mean(df$imputed_land_value, na.rm=T)
df[is.na(df$assessed_improvement_value), 'assessed_improvement_value'] <- mean(df$assessed_improvement_value, na.rm=T)

df <- df[df['revenue'] > 0,]
df['costs'] = (df['construction_cost_est'] + df['imputed_land_value']
               + pmax(df['assessed_improvement_value'] - df['fire_damage'], 0))

df <- df[!duplicated(df[, c("MapBlkLot_Master", "year")]), ]

df['D'] = df['revenue']/df['costs']
df <- df[!is.na(df$D), ]


df <- df %>%
  arrange(MapBlkLot_Master, year) %>%
  group_by(MapBlkLot_Master) %>%
  mutate(Developed_Previously = cumsum(lag(Developed, default = FALSE)) > 0) %>%
  ungroup()


```

```{r}
non.res.df <- df %>%
  filter(!use_definition %in% c('Multi-Family Residential', 'Single Family Residential'))

nrow(non.res.df)
non.res.pd <- pdata.frame(non.res.df, index=c("MapBlkLot_Master", "year"))

```

```{r}
pd <- pdata.frame(df, index=c("MapBlkLot_Master", "year"))
pdim(pd)

```

### Hausman test page 131 of Wooldridge

```{r}

page131 <- plm(D ~ fire_category,
               data=pd, effect='twoways',  model='within')
page131b <- plm(log1p(Net_Units_Completed) ~ resid(page131) + fire_category,
                data=pd, effect='twoways',  model='within')
summary.w1 <- summary(page131b, vcov = function(x) vcovHC(x, method="white1", type="HC1"))
summary.w3 <- summary(page131b, vcov = function(x) vcovHC(x, method="white1", type="HC3"))
summary.a1 <- summary(page131b, vcov = function(x) vcovHC(x, method="arellano", type="HC1"))
summary.a3 <- summary(page131b, vcov = function(x) vcovHC(x, method="arellano", type="HC3"))

get_ci <- function(summary.of.model){
  c(summary.of.model$coef[1, 'Estimate'] - 1.96 * summary.of.model$coef[1, 'Std. Error'],
    summary.of.model$coef[1, 'Estimate'] + 1.96 * summary.of.model$coef[1, 'Std. Error'])
}

round(summary.a1$coef[1, 'Pr(>|t|)'], 4)
round(summary.a3$coef[1, 'Pr(>|t|)'], 4)
round(summary.w1$coef[1, 'Pr(>|t|)'], 4)
round(summary.w3$coef[1, 'Pr(>|t|)'], 4)
round(get_ci(summary.a1), 4)
round(get_ci(summary.a3), 4)
round(get_ci(summary.w1), 4)
round(get_ci(summary.w3), 4)


#phtest( method ="aux", data=pd, vcov = function(x) vcovHC(x, method="white2", type="HC3"))
```

### Linear Probability Model (pooled)

```{r}
# test correlation with observed confounders
library("lmtest")
obs.confound.mod <- lm(log1p(fire_damage) ~ Upzone_Ratio + Envelope_1000 + Residential_Dummy + zp_OfficeComm, data=df)

summary(obs.confound.mod)

coeftest(obs.confound.mod, vcov = vcovHC(obs.confound.mod, type = "HC0"))

```

```{r}
df$fire_category <- df$fire_category == 'after_fire'

obs.confound.mod <- glm(fire_category ~ Upzone_Ratio + Envelope_1000 + Residential_Dummy + zp_OfficeComm, data=df, family='binomial')

obs.confound.mod
```

```{r}
RSS_reduced <- sum(resid(first.stage.non)^2)
RSS_full <- sum(resid(first.stage.mod)^2)

# Calculate the partial R squared for including x2
partial_R2 <- (RSS_reduced - RSS_full) / RSS_reduced
partial_R2
```



```{r}
fixef(iv_model.lpm, effect='time')
```

# Linear Model

```{r}

formula <- log1p(Net_Units_Completed) ~ log(D) + year:zp_DensRestMulti + zp_OfficeComm:year + year:zp_FormBasedMulti + year:zp_Public + year:zp_PDRInd + year:zp_Public + year:zp_RH2 + year:zp_RH3_RM1 + year:zp_Redev | fire_category + year:zp_DensRestMulti + zp_OfficeComm:year + year:zp_FormBasedMulti + year:zp_Public + year:zp_PDRInd + year:zp_Public + year:zp_RH2 + year:zp_RH3_RM1 + year:zp_Redev

# Estimate using 2SLS for panel data
iv_model.pool <- plm::plm(formula, data = pd, model="pooling")
summary(iv_model.pool)

```

```{r}
colnames(pd)

formula <- log1p(Net_Units_Completed) ~ log(D) + year:zp_DensRestMulti + zp_OfficeComm:year + year:zp_FormBasedMulti + year:zp_Public + year:zp_PDRInd + year:zp_Public + year:zp_RH2 + year:zp_RH3_RM1 + year:zp_Redev | fire_category + year:zp_DensRestMulti + zp_OfficeComm:year + year:zp_FormBasedMulti + year:zp_Public + year:zp_PDRInd + year:zp_Public + year:zp_RH2 + year:zp_RH3_RM1 + year:zp_Redev

# Estimate using 2SLS for panel data
iv_model.wi <- plm::plm(formula, data = pd, effect = 'twoway', model='within')
iv_model.hc1 <- summary(iv_model.wi, vcov = function(x) vcovHC(x, method="white1", type="HC1"))

iv_model.wi.hc1.estimate <- -3.3193e-01
iv_model.wi.hc1.std.err <- 2.4197e-01
round(c(iv_model.wi.hc1.estimate - 1.96*iv_model.wi.hc1.std.err, 
        iv_model.wi.hc1.estimate + 1.96*iv_model.wi.hc1.std.err), 4)


iv_model.hc3 <- summary(iv_model.wi, vcov = function(x) vcovHC(x, method="white1", type="HC3"))
iv_model.hc3
round(c(-3.3193e-01 - 1.96 * 2.4254e-01, -3.3193e-01 + 1.96 * 2.4254e-01), 4)
```


```{r}
summary(iv_model.wi, vcov = function(x) vcovHC(x, method="white1", type="HC3"))
```

```{r}

library(sandwich)
library(lmtest)

ols.mod <- lm(log1p(Net_Units_Completed) ~ log(D) + year:zp_DensRestMulti + zp_OfficeComm:year + year:zp_FormBasedMulti + year:zp_Public + year:zp_PDRInd + year:zp_Public + year:zp_RH2 + year:zp_RH3_RM1 + year:zp_Redev, data=df)

robust_cov1 <- vcovHC(ols.mod, type = "HC1")
robust_cov3 <- vcovHC(ols.mod, type = "HC3")
round(c(-1.3060e-03 - 1.96 * 1.2245e-04, -1.3060e-03 + 1.96 * 1.2245e-04), 4)
coeftest(ols.mod, robust_cov1)
summary(ols.mod)
round(c(-1.3060e-03 - 1.96 * 1.2245e-04, -1.3060e-03 + 1.96 * 1.2245e-04), 4)
coeftest(ols.mod, robust_cov3)
```
## Robustness Check

```{r}
ols.mod.non.res <- lm(log1p(Net_Units_Completed) ~ log(D) + year:zp_DensRestMulti + zp_OfficeComm:year + year:zp_FormBasedMulti + year:zp_Public + year:zp_PDRInd + year:zp_Public + year:zp_RH2 + year:zp_RH3_RM1 + year:zp_Redev, data=non.res.df)

robust_cov1 <- vcovHC(ols.mod.non.res, type = "HC1")
robust_cov3 <- vcovHC(ols.mod.non.res, type = "HC3")
round(c(-2.6192e-03 - 1.96 * 9.1759e-04, -2.6192e-03 + 1.96 * 9.1759e-04), 4)
round(coeftest(ols.mod.non.res, robust_cov1)['log(D)', 'Pr(>|t|)'], 4)
round(c(-2.6192e-03 - 1.96 * 7.5582e-04, -2.6192e-03 + 1.96 * 7.5582e-04), 4)
round(coeftest(ols.mod.non.res, robust_cov3)['log(D)', 'Pr(>|t|)'], 4)


iv_model.wi.non.res <- plm::plm(formula, data = non.res.pd, effect = 'twoway', model='within')
iv_model.hc1.non.res <- summary(iv_model.wi.non.res, 
                                vcov = function(x) vcovHC(x, method="white1", type="HC1"))

round(iv_model.hc1.non.res$coef['log(D)', 'Pr(>|z|)'], 4)
round(c(0.71760338 - 1.96 * 1.01280558, 0.71760338 + 1.96 * 1.01280558), 4)
iv_model.hc3.non.res <- summary(iv_model.wi.non.res, 
                                vcov = function(x) vcovHC(x, method="white1", type="HC3"))

round(iv_model.hc3.non.res$coef['log(D)', 'Pr(>|z|)'], 4)

iv_model.hc3.non.res
round(c(0.71760338 - 1.96 * 1.02032123, 0.71760338 + 1.96 * 1.02032123), 4)
```